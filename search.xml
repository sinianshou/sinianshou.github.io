<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Shortest Subarray with Sum at Least K 求数组中区间和大于等于 K 的最小子数组长度</title>
    <url>/2020/01/06/Shortest-Subarray-with-Sum-at-Least-K-%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8C%BA%E9%97%B4%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br>If there is no non-empty subarray with sum at least K, return -1.</p>
<p>Example 1:<br>Input: A = [1], K = 1<br>Output: 1</p>
<p>Example 2:<br>Input: A = [1,2], K = 4<br>Output: -1</p>
<p>Example 3:<br>Input: A = [2,-1,2], K = 3<br>Output: 3</p>
<p>Note:<br>1 &lt;= A.length &lt;= 50000<br>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5<br>1 &lt;= K &lt;= 10 ^ 9</p>
<p>找出数组 A 中其和大于等于 K 的最小、非空、连续子数组长度：</p>
<ol>
<li><p>A 中整数范围为 -10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</p>
</li>
<li><p>A 数组长度范围为 1 &lt;= A.length &lt;= 50000</p>
</li>
<li><p>K 的取值范围为 1 &lt;= K &lt;= 10 ^ 9</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题求数组 A 中加和值 &gt;=K 最小连续子数组长度，既然是连续子数组的问题，可以将数组 A 转换成累加数组 sums ，区间和[i, j] = sum[j] - sums[i-1]，所以就转换成求 sums 中差值 &gt;=K 的两个元素问题。<br>若 A 元素均为正数，以 A = [2, 1, 2] ，K = 2 为例：</p>
</li>
<li><p>sums = [0, 2, 3, 5]，为升序数组，不断将 sums[i] 与其之前的元素进行比较</p>
</li>
<li><p>二层遍历中，当找到 sums[1] - sums[0] &gt;= K 满足条件</p>
</li>
<li><p>由于sums[i] (i&gt;1) &gt;= sums[1]，肯定满足 &gt;=K 的条件</p>
</li>
<li><p>但 i 距离 0 一定比 1 远，所以可以跳出循环，不用继续比较。</p>
</li>
</ol>
<p>但 A 元素有负数的可能，sums 即非有序数组，所以无法在找到符合条件的两个元素后就终止二层遍历，但我们可以在二层遍历中直接过滤掉一些没必要的比较。</p>
<p>以 A = [1,1, -1, 2] ，K = 1 为例：</p>
<ol>
<li>sums = [0, 1, 2, 1, 3] ，为非有序数组</li>
<li>我们可以看到当 sums[4] 逐一对 sums[0 … 3] 进行比较时，由于 sums[3] &lt;= sums[2]，则若 sums[4] - sums[2] &gt;= K，那么 sums[4] - sums[3] &gt;= sums[4]-sums[2] &gt;= K 一定为真</li>
<li>而序号 4 - 3 &lt; 4 - 2，所以 sums[4] 与 sums[2] 是没有必要比较的</li>
<li>同理 sums[4] 与 sums[1] 也是没有必要比较的</li>
<li>所以声明个比较队列 dq 来存储需要比较的序号</li>
<li>在遍历比较时，运用 sums[i] &lt;= sums[j] 的方式，将 j 从比较队列中排除</li>
<li>同时在比较时更新最小值为结果</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestSubarray</span><span class="params">(<span class="number">_</span> A: [Int], <span class="number">_</span> K: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="comment">//A的长度n</span></span><br><span class="line">        <span class="keyword">let</span> n = <span class="type">A</span>.<span class="built_in">count</span>;</span><br><span class="line">        <span class="comment">//初始化结果res，初始值为max</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Int</span>.<span class="built_in">max</span>;</span><br><span class="line">        <span class="comment">//初始化队列dq</span></span><br><span class="line">        <span class="keyword">var</span> dq = [<span class="type">Int</span>]();</span><br><span class="line">        <span class="comment">//初始化累加队列sums</span></span><br><span class="line">        <span class="keyword">var</span> sums = [<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="type">A</span>&#123;</span><br><span class="line">            sums.append(sums.last! + a)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历sums</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... n&#123;</span><br><span class="line">            <span class="comment">//当队列不为空，且 [dq[0], i] 符合条件时，更新 res ，dq 删除头</span></span><br><span class="line">            <span class="keyword">while</span> (dq.<span class="built_in">count</span> &gt; <span class="number">0</span> &amp;&amp; sums[i] - sums[dq[<span class="number">0</span>]] &gt;= <span class="type">K</span>)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, i - dq[<span class="number">0</span>]);</span><br><span class="line">                dq.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当队列不为空，且 [dq.last, i] &lt;= 0 时， dq 删除尾</span></span><br><span class="line">            <span class="keyword">while</span> (dq.<span class="built_in">count</span> &gt; <span class="number">0</span> &amp;&amp; sums[i] &lt;= sums[dq.last!])&#123;</span><br><span class="line">                dq.remove(at: dq.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 i 加入 dq 尾部</span></span><br><span class="line">            dq.append(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res == <span class="type">Int</span>.<span class="built_in">max</span> ? -<span class="number">1</span> : res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://github.com/sinianshou/EGSwiftLearning" target="_blank" rel="noopener">https://github.com/sinianshou/EGSwiftLearning</a></p>
]]></content>
      <categories>
        <category>每周一算</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>上证、深证。沪深是什么</title>
    <url>/2020/01/03/%E4%B8%8A%E8%AF%81%E3%80%81%E6%B7%B1%E8%AF%81%E3%80%82%E6%B2%AA%E6%B7%B1%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>金融理财</category>
      </categories>
      <tags>
        <tag>金融概念</tag>
      </tags>
  </entry>
  <entry>
    <title>北向资金、南向资金、主力、散户是什么</title>
    <url>/2020/01/03/%E5%8C%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E5%8D%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E4%B8%BB%E5%8A%9B%E3%80%81%E6%95%A3%E6%88%B7%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="北向资金是什么"><a href="#北向资金是什么" class="headerlink" title="北向资金是什么"></a>北向资金是什么</h2><p>狭义上讲，是通过沪港通和深港通进入沪市和深市的“香港”资金，而香港在地理位置上是南方，所以资金是从南向北流入，也就形象的称之为北向资金。但从广义上讲，北向资金指的应该是境外的投资者通过各种渠道进入中国股市的的资金。基本上分为三类：</p>
<h3 id="通过沪深港通进入中国股市的境外资金"><a href="#通过沪深港通进入中国股市的境外资金" class="headerlink" title="通过沪深港通进入中国股市的境外资金"></a>通过沪深港通进入中国股市的境外资金</h3><p>境外投资者通过沪深港通进入中国A股市场进行投资，当然也有部分大陆资金经过沪深港通杠杆之后再进入A股市场投资，这部分也戏称为“假外资”。由于境外投资历史更长，投资者投案方案比较成熟，所以北向资金对于股市有一定的影响力，是较为重要的信号指标。</p>
<h3 id="合格境外投资机构（QFII）"><a href="#合格境外投资机构（QFII）" class="headerlink" title="合格境外投资机构（QFII）"></a>合格境外投资机构（QFII）</h3><p>2002年，合格境外投资机构（Qualified Foreign Institutional Investors ，QFII）制度正式出台，是我国第一次允许经过审批的合格境外投资机构投资A股。</p>
<h3 id="合格境外人民币投资机构（RQFII）"><a href="#合格境外人民币投资机构（RQFII）" class="headerlink" title="合格境外人民币投资机构（RQFII）"></a>合格境外人民币投资机构（RQFII）</h3><p>与QFII使用美元投资相对应，RQFII是使用离岸人民币进行投资。</p>
<h2 id="南向资金是什么"><a href="#南向资金是什么" class="headerlink" title="南向资金是什么"></a>南向资金是什么</h2><p>…<br>待补充</p>
]]></content>
      <categories>
        <category>金融理财</category>
      </categories>
      <tags>
        <tag>金融概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>元素重复三次的数组中查找重复一次的元素</title>
    <url>/2019/10/09/%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%89%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个大数组，它里面除了一个元素外，其他元素都重复了三次，要求在<strong>空间复杂度为O(1)</strong>, <strong>时间复杂度为O(n)</strong>的约束下，查找到只重复了一次的元素。<br>意思就是说：这意味着算法必须对数组遍历1次就要找出给定元素。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考位图算法，</p>
<ul>
<li>声明两个变量 firstAppear(FA) 和 secondAppear(SA) ，初始值均为零</li>
<li>当某一位第一次出现1时，FA的该位值为1</li>
<li>当想通位第二次出现1时，FA该位值为0，SA该位值为1</li>
<li>当想通位第三次出现1时，FA该位值为0，SA该位值为0</li>
</ul>
<p>这样，出现三次的数值都会被过滤掉，而只出现一次的数值会留在FA中。<br>假设 E 为元素某位的值，我们需要有 newFA 和 newSA 来临时储存新的值，按照结果推到出关于 newFA 的如下表格：</p>
<table>
<thead>
<tr>
<th>SA/E</th>
<th>0/0</th>
<th>0/1</th>
<th>1/0</th>
<th>1/1</th>
</tr>
</thead>
<tbody><tr>
<td>FA=0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>FA=1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>我们需要由这个表格推导出 newFA 与 FA、SA、E的位运算关系：</p>
<ul>
<li>SA 为0时，缩小了取值范围，并覆盖了 newFA==1 的范围，即得出一个 &amp; 运算因子 ~SA</li>
<li>当 FA/E 为 0/1 或 1/0 时，进一步缩小了取值范围，且恰好与所有 newFA==1 的范围匹配，得出 &amp; 运算因子 FA^E</li>
</ul>
<p>所以newFA 与 FA、SA、E的位运算关系为 newFA = ~SA &amp; (FA^E)</p>
<p>newSA 的如下表格：</p>
<table>
<thead>
<tr>
<th>FA/E</th>
<th>0/0</th>
<th>0/1</th>
<th>1/0</th>
<th>1/1</th>
</tr>
</thead>
<tbody><tr>
<td>SA=0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>SA=1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>由这个表格推导 newSA 与 FA、SA、E的位运算关系：</p>
<ul>
<li>SA 与 E 相反时，缩小了取值范围，并覆盖了 newSA==1 的范围，即得出一个 &amp; 运算因子 SA^E</li>
<li>当 FA/E 为 0/0 或 1/1 时，进一步缩小了取值范围，且恰好与所有 newSA==1 的范围匹配，得出 &amp; 运算因子 ~(FA^E)</li>
</ul>
<p>所以newFA 与 FA、SA、E的位运算关系为 newSA = (SA^E) &amp; ~(FA^E)<br>之后再把 FA = newFA 和 SA = newSA 即可。<br><strong>PS</strong>:推导的原则基本上就是不断缩小取值范围，直至完全匹配，然后用 &amp; 连接运算因子。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>Swift code:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4];</span><br><span class="line">var FA &#x3D; 0</span><br><span class="line">var SA &#x3D; 0</span><br><span class="line">var newFA &#x3D; 0</span><br><span class="line">var newSA &#x3D; 0</span><br><span class="line">for E in arr&#123;</span><br><span class="line">newFA &#x3D; (SA^E) &amp; ~(FA^E)</span><br><span class="line">newFA &#x3D; ~SA &amp; (FA^E)</span><br><span class="line">FA &#x3D; newFA</span><br><span class="line">SA &#x3D; newSA</span><br><span class="line">&#125;</span><br><span class="line">print(FA)</span><br><span class="line">&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>:若是查找该数组中仅有的重复两次的元素，SA即是</p>
]]></content>
      <categories>
        <category>每周一算</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>swift</tag>
      </tags>
  </entry>
</search>
