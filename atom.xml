<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sinianshou.github.io/"/>
  <updated>2020-01-19T01:20:34.964Z</updated>
  <id>https://sinianshou.github.io/</id>
  
  <author>
    <name>Easer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Substring with Concatenation of All Words 所有单词链接而成的子串</title>
    <link href="https://sinianshou.github.io/2020/01/19/Substring-with-Concatenation-of-All-Words-%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E9%93%BE%E6%8E%A5%E8%80%8C%E6%88%90%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>https://sinianshou.github.io/2020/01/19/Substring-with-Concatenation-of-All-Words-%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E9%93%BE%E6%8E%A5%E8%80%8C%E6%88%90%E7%9A%84%E5%AD%90%E4%B8%B2/</id>
    <published>2020-01-19T01:11:39.000Z</published>
    <updated>2020-01-19T01:20:34.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p>Example 1:</p><p>Input:<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>Output: [0,9]<br>Explanation: Substrings starting at index 0 and 9 are “barfoo” and “foobar” respectively.<br>The output order does not matter, returning [9,0] is fine too.<br>Example 2:</p><p>Input:<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>Output: []</p><p>给出一个字符串 s ，和一个单词数组 words，words 中所有的单词长度相同，找出 s 中，由 words 所有单词拼接而成的子串的起始索引。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为 words 中所有的单词长度是相同的，所以可以考虑以固定的单词长度为切割，遍历比较每个单词：</p><ol><li>用 words 创建 map，key 为单词，value 为单词的数量。</li><li>s 长度 sLen，单词个数 wCount，单词长度 wLen，存储结果数组 result。</li><li>由于是遍历比较单词，所以两层遍历，外层的遍历 i 是 0 到 wLen-1，里层遍历 j 为 i 到 sLen-wLen，每次增长 wLen。</li><li>外层遍历：将 left 索引移动到 i ，总匹配成功单词数量 count = 0，创建单词匹配池 pairPool，key 为单词，匹配数量 value 为 0 。</li><li>里层遍历：<ul><li>获取 s 中的单词 subStr，若匹配成功，则 pairPool 中对应匹配数量 +1，总匹配成功单词数量 +1</li><li>匹配成功之后，如果 subStr 匹配成功数量大于 words 中的数量，则说明 subStr 匹配过多，需要从 left 开始逐一抛弃单词，直至subStr 匹配数量与 words 中的数量一致</li><li>如果 总匹配成功单词数量 count 等于 wCount，则说明在该次比较中，words 的所有单词均匹配成功，left 即为一个结果，将 left 加入到 result中，count -1，left 右移 wLen</li><li>如果 subStr 匹配失败，则抛弃之前的匹配数据，重置 pairPool、count，将left 重置到 j + wLen处</li></ul></li><li>两层遍历结束后，返回结果 result </li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> words: [String])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="comment">//如果 s 或者 words 为空，则返回 []</span></span><br><span class="line">        <span class="keyword">if</span> s.isEmpty || words.<span class="built_in">count</span>&lt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//声明 s 长度 sLen，单词个数 wCount，单词长度 wLen</span></span><br><span class="line">        <span class="keyword">let</span> sLen = s.<span class="built_in">count</span>, wCount = words.<span class="built_in">count</span>, wLen = words.first!.<span class="built_in">count</span></span><br><span class="line">        <span class="comment">//声明 result 存储结果用</span></span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="comment">// map 用于存储 words 中每个单词的个数</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">map</span> = [<span class="type">String</span>:<span class="type">Int</span>]()</span><br><span class="line">        <span class="comment">// pairPool1 用于重新初始化匹配单词池</span></span><br><span class="line">        <span class="keyword">var</span> pairPool1 = [<span class="type">String</span>:<span class="type">Int</span>]()</span><br><span class="line">        <span class="comment">// 配置 map 和 pairPool1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>.keys.<span class="built_in">contains</span>(word) &#123;</span><br><span class="line">                <span class="built_in">map</span>[word]! += <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">map</span>[word] = <span class="number">1</span></span><br><span class="line">                pairPool1[word] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历从 0 到 wLen-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; wLen &#123;</span><br><span class="line">            <span class="comment">// left 为目标子串的左索引， count 为已经匹配成功的单词个数</span></span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">left</span> = i, <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">            <span class="comment">//将pairPool1 复制给 pairPool 进行初始化，pairPool 用以存储每个单词已经匹配的个数</span></span><br><span class="line">            <span class="keyword">var</span> pairPool = pairPool1</span><br><span class="line">            <span class="comment">// 从 i 开始，wlen 为长度，sLen=wLen 为尾，遍历每个单词</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">stride</span>(from: i, through: sLen-wLen, by: wLen) &#123;</span><br><span class="line">                <span class="comment">//获取 s 中 j 索引处的单词 subStr</span></span><br><span class="line">                <span class="keyword">let</span> jIndex = s.index(s.startIndex, offsetBy: j)</span><br><span class="line">                <span class="keyword">let</span> subStr = <span class="type">String</span>(s[jIndex ..&lt; s.index(jIndex, offsetBy: wLen)])</span><br><span class="line">                <span class="comment">//如果 words 中含有该单词，则单词匹配成功</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">map</span>.keys.<span class="built_in">contains</span>(subStr) &#123;</span><br><span class="line">                    <span class="comment">//单词匹配成功，在匹配池中，subStr 的匹配数量 +1 ，总匹配数量 count +1</span></span><br><span class="line">                    pairPool[subStr]! += <span class="number">1</span></span><br><span class="line">                    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">                    <span class="comment">//如果 s 中 subStr 匹配数量大于 words 中的数量，则从 left 开始逐一抛弃单词</span></span><br><span class="line">                    <span class="comment">//直至 s 中 subStr 匹配数量等于 words 中的数量</span></span><br><span class="line">                    <span class="keyword">while</span> pairPool[subStr]! &gt; <span class="built_in">map</span>[subStr]! &#123;</span><br><span class="line">                        <span class="comment">//获取 left 索引处单词 lSubStr</span></span><br><span class="line">                        <span class="keyword">let</span> lIndex = s.index(s.startIndex, offsetBy: <span class="keyword">left</span>)</span><br><span class="line">                        <span class="keyword">let</span> lSubStr = <span class="type">String</span>(s[lIndex ..&lt; s.index(lIndex, offsetBy: wLen)])</span><br><span class="line">                        <span class="comment">// lSubStr 匹配成功数量 -1</span></span><br><span class="line">                        pairPool[lSubStr]! -= <span class="number">1</span></span><br><span class="line">                        <span class="comment">//总匹配成功单词数量 count -1</span></span><br><span class="line">                        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">                        <span class="comment">// left 右移 wLen 位</span></span><br><span class="line">                        <span class="keyword">left</span> += wLen</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果 count 等于 wCount，则说明在该次比较中，words 的所有单词均匹配成功，left 即为一个结果</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">count</span> == wCount &#123;</span><br><span class="line">                        <span class="comment">// words 中所有单词匹配成功，将结果 left 添加到 result 中</span></span><br><span class="line">                        result.append(<span class="keyword">left</span>)</span><br><span class="line">                        <span class="comment">//获取 left 索引处单词 lSubStr</span></span><br><span class="line">                        <span class="keyword">let</span> lIndex = s.index(s.startIndex, offsetBy: <span class="keyword">left</span>)</span><br><span class="line">                        <span class="keyword">let</span> lSubStr = <span class="type">String</span>(s[lIndex ..&lt; s.index(lIndex, offsetBy: wLen)])</span><br><span class="line">                        <span class="comment">// lSubStr 匹配成功数量 -1</span></span><br><span class="line">                        pairPool[lSubStr]! -= <span class="number">1</span></span><br><span class="line">                        <span class="comment">//总匹配成功单词数量 count -1</span></span><br><span class="line">                        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">                        <span class="comment">// left 右移 wLen 位</span></span><br><span class="line">                        <span class="keyword">left</span> += wLen</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//若 words 中没有该单词，则说明匹配失败，抛弃之前的匹配数据，重置 pairPool、count，将left 重置到 j + wLen处</span></span><br><span class="line">                    pairPool = pairPool1</span><br><span class="line">                    <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">left</span> = j + wLen</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/sinianshou/EGSwiftLearning" target="_blank" rel="noopener">https://github.com/sinianshou/EGSwiftLearning</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;You are given a string, s, and a list of words, words, that are all of
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>正回购与逆回购</title>
    <link href="https://sinianshou.github.io/2020/01/15/%E6%AD%A3%E5%9B%9E%E8%B4%AD%E4%B8%8E%E9%80%86%E5%9B%9E%E8%B4%AD/"/>
    <id>https://sinianshou.github.io/2020/01/15/%E6%AD%A3%E5%9B%9E%E8%B4%AD%E4%B8%8E%E9%80%86%E5%9B%9E%E8%B4%AD/</id>
    <published>2020-01-15T01:31:59.000Z</published>
    <updated>2020-01-15T01:31:59.894Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Shortest Subarray with Sum at Least K 求数组中区间和大于等于 K 的最小子数组长度</title>
    <link href="https://sinianshou.github.io/2020/01/06/Shortest-Subarray-with-Sum-at-Least-K-%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8C%BA%E9%97%B4%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://sinianshou.github.io/2020/01/06/Shortest-Subarray-with-Sum-at-Least-K-%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8C%BA%E9%97%B4%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</id>
    <published>2020-01-06T07:48:01.000Z</published>
    <updated>2020-01-06T07:50:28.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br>If there is no non-empty subarray with sum at least K, return -1.</p><p>Example 1:<br>Input: A = [1], K = 1<br>Output: 1</p><p>Example 2:<br>Input: A = [1,2], K = 4<br>Output: -1</p><p>Example 3:<br>Input: A = [2,-1,2], K = 3<br>Output: 3</p><p>Note:<br>1 &lt;= A.length &lt;= 50000<br>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5<br>1 &lt;= K &lt;= 10 ^ 9</p><p>找出数组 A 中其和大于等于 K 的最小、非空、连续子数组长度：</p><ol><li><p>A 中整数范围为 -10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</p></li><li><p>A 数组长度范围为 1 &lt;= A.length &lt;= 50000</p></li><li><p>K 的取值范围为 1 &lt;= K &lt;= 10 ^ 9</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题求数组 A 中加和值 &gt;=K 最小连续子数组长度，既然是连续子数组的问题，可以将数组 A 转换成累加数组 sums ，区间和[i, j] = sum[j] - sums[i-1]，所以就转换成求 sums 中差值 &gt;=K 的两个元素问题。<br>若 A 元素均为正数，以 A = [2, 1, 2] ，K = 2 为例：</p></li><li><p>sums = [0, 2, 3, 5]，为升序数组，不断将 sums[i] 与其之前的元素进行比较</p></li><li><p>二层遍历中，当找到 sums[1] - sums[0] &gt;= K 满足条件</p></li><li><p>由于sums[i] (i&gt;1) &gt;= sums[1]，肯定满足 &gt;=K 的条件</p></li><li><p>但 i 距离 0 一定比 1 远，所以可以跳出循环，不用继续比较。</p></li></ol><p>但 A 元素有负数的可能，sums 即非有序数组，所以无法在找到符合条件的两个元素后就终止二层遍历，但我们可以在二层遍历中直接过滤掉一些没必要的比较。</p><p>以 A = [1,1, -1, 2] ，K = 1 为例：</p><ol><li>sums = [0, 1, 2, 1, 3] ，为非有序数组</li><li>我们可以看到当 sums[4] 逐一对 sums[0 … 3] 进行比较时，由于 sums[3] &lt;= sums[2]，则若 sums[4] - sums[2] &gt;= K，那么 sums[4] - sums[3] &gt;= sums[4]-sums[2] &gt;= K 一定为真</li><li>而序号 4 - 3 &lt; 4 - 2，所以 sums[4] 与 sums[2] 是没有必要比较的</li><li>同理 sums[4] 与 sums[1] 也是没有必要比较的</li><li>所以声明个比较队列 dq 来存储需要比较的序号</li><li>在遍历比较时，运用 sums[i] &lt;= sums[j] 的方式，将 j 从比较队列中排除</li><li>同时在比较时更新最小值为结果</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestSubarray</span><span class="params">(<span class="number">_</span> A: [Int], <span class="number">_</span> K: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="comment">//A的长度n</span></span><br><span class="line">        <span class="keyword">let</span> n = <span class="type">A</span>.<span class="built_in">count</span>;</span><br><span class="line">        <span class="comment">//初始化结果res，初始值为max</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Int</span>.<span class="built_in">max</span>;</span><br><span class="line">        <span class="comment">//初始化队列dq</span></span><br><span class="line">        <span class="keyword">var</span> dq = [<span class="type">Int</span>]();</span><br><span class="line">        <span class="comment">//初始化累加队列sums</span></span><br><span class="line">        <span class="keyword">var</span> sums = [<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="type">A</span>&#123;</span><br><span class="line">            sums.append(sums.last! + a)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历sums</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... n&#123;</span><br><span class="line">            <span class="comment">//当队列不为空，且 [dq[0], i] 符合条件时，更新 res ，dq 删除头</span></span><br><span class="line">            <span class="keyword">while</span> (dq.<span class="built_in">count</span> &gt; <span class="number">0</span> &amp;&amp; sums[i] - sums[dq[<span class="number">0</span>]] &gt;= <span class="type">K</span>)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, i - dq[<span class="number">0</span>]);</span><br><span class="line">                dq.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当队列不为空，且 [dq.last, i] &lt;= 0 时， dq 删除尾</span></span><br><span class="line">            <span class="keyword">while</span> (dq.<span class="built_in">count</span> &gt; <span class="number">0</span> &amp;&amp; sums[i] &lt;= sums[dq.last!])&#123;</span><br><span class="line">                dq.remove(at: dq.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 i 加入 dq 尾部</span></span><br><span class="line">            dq.append(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res == <span class="type">Int</span>.<span class="built_in">max</span> ? -<span class="number">1</span> : res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/sinianshou/EGSwiftLearning" target="_blank" rel="noopener">https://github.com/sinianshou/EGSwiftLearning</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Return the length of the shortest, non-empty, contiguous subarray of A
      
    
    </summary>
    
    
      <category term="每周一算" scheme="https://sinianshou.github.io/categories/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%AE%97/"/>
    
    
      <category term="算法" scheme="https://sinianshou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="swift" scheme="https://sinianshou.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>上证、深证。沪深是什么</title>
    <link href="https://sinianshou.github.io/2020/01/03/%E4%B8%8A%E8%AF%81%E3%80%81%E6%B7%B1%E8%AF%81%E3%80%82%E6%B2%AA%E6%B7%B1%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://sinianshou.github.io/2020/01/03/%E4%B8%8A%E8%AF%81%E3%80%81%E6%B7%B1%E8%AF%81%E3%80%82%E6%B2%AA%E6%B7%B1%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-01-03T08:34:59.000Z</published>
    <updated>2020-01-03T08:52:40.444Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="金融理财" scheme="https://sinianshou.github.io/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融概念" scheme="https://sinianshou.github.io/tags/%E9%87%91%E8%9E%8D%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>北向资金、南向资金、主力、散户是什么</title>
    <link href="https://sinianshou.github.io/2020/01/03/%E5%8C%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E5%8D%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E4%B8%BB%E5%8A%9B%E3%80%81%E6%95%A3%E6%88%B7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://sinianshou.github.io/2020/01/03/%E5%8C%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E5%8D%97%E5%90%91%E8%B5%84%E9%87%91%E3%80%81%E4%B8%BB%E5%8A%9B%E3%80%81%E6%95%A3%E6%88%B7%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-01-03T08:33:10.000Z</published>
    <updated>2020-01-03T08:52:34.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="北向资金是什么"><a href="#北向资金是什么" class="headerlink" title="北向资金是什么"></a>北向资金是什么</h2><p>狭义上讲，是通过沪港通和深港通进入沪市和深市的“香港”资金，而香港在地理位置上是南方，所以资金是从南向北流入，也就形象的称之为北向资金。但从广义上讲，北向资金指的应该是境外的投资者通过各种渠道进入中国股市的的资金。基本上分为三类：</p><h3 id="通过沪深港通进入中国股市的境外资金"><a href="#通过沪深港通进入中国股市的境外资金" class="headerlink" title="通过沪深港通进入中国股市的境外资金"></a>通过沪深港通进入中国股市的境外资金</h3><p>境外投资者通过沪深港通进入中国A股市场进行投资，当然也有部分大陆资金经过沪深港通杠杆之后再进入A股市场投资，这部分也戏称为“假外资”。由于境外投资历史更长，投资者投案方案比较成熟，所以北向资金对于股市有一定的影响力，是较为重要的信号指标。</p><h3 id="合格境外投资机构（QFII）"><a href="#合格境外投资机构（QFII）" class="headerlink" title="合格境外投资机构（QFII）"></a>合格境外投资机构（QFII）</h3><p>2002年，合格境外投资机构（Qualified Foreign Institutional Investors ，QFII）制度正式出台，是我国第一次允许经过审批的合格境外投资机构投资A股。</p><h3 id="合格境外人民币投资机构（RQFII）"><a href="#合格境外人民币投资机构（RQFII）" class="headerlink" title="合格境外人民币投资机构（RQFII）"></a>合格境外人民币投资机构（RQFII）</h3><p>与QFII使用美元投资相对应，RQFII是使用离岸人民币进行投资。</p><h2 id="南向资金是什么"><a href="#南向资金是什么" class="headerlink" title="南向资金是什么"></a>南向资金是什么</h2><p>…<br>待补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;北向资金是什么&quot;&gt;&lt;a href=&quot;#北向资金是什么&quot; class=&quot;headerlink&quot; title=&quot;北向资金是什么&quot;&gt;&lt;/a&gt;北向资金是什么&lt;/h2&gt;&lt;p&gt;狭义上讲，是通过沪港通和深港通进入沪市和深市的“香港”资金，而香港在地理位置上是南方，所以资金是从南
      
    
    </summary>
    
    
      <category term="金融理财" scheme="https://sinianshou.github.io/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="金融概念" scheme="https://sinianshou.github.io/tags/%E9%87%91%E8%9E%8D%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sinianshou.github.io/2020/01/03/hello-world/"/>
    <id>https://sinianshou.github.io/2020/01/03/hello-world/</id>
    <published>2020-01-03T02:19:24.811Z</published>
    <updated>2020-01-03T08:30:58.479Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>元素重复三次的数组中查找重复一次的元素</title>
    <link href="https://sinianshou.github.io/2019/10/09/%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%89%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://sinianshou.github.io/2019/10/09/%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%89%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2019-10-09T12:12:14.000Z</published>
    <updated>2020-01-06T07:52:36.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个大数组，它里面除了一个元素外，其他元素都重复了三次，要求在<strong>空间复杂度为O(1)</strong>, <strong>时间复杂度为O(n)</strong>的约束下，查找到只重复了一次的元素。<br>意思就是说：这意味着算法必须对数组遍历1次就要找出给定元素。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考位图算法，</p><ul><li>声明两个变量 firstAppear(FA) 和 secondAppear(SA) ，初始值均为零</li><li>当某一位第一次出现1时，FA的该位值为1</li><li>当想通位第二次出现1时，FA该位值为0，SA该位值为1</li><li>当想通位第三次出现1时，FA该位值为0，SA该位值为0</li></ul><p>这样，出现三次的数值都会被过滤掉，而只出现一次的数值会留在FA中。<br>假设 E 为元素某位的值，我们需要有 newFA 和 newSA 来临时储存新的值，按照结果推到出关于 newFA 的如下表格：</p><table><thead><tr><th>SA/E</th><th>0/0</th><th>0/1</th><th>1/0</th><th>1/1</th></tr></thead><tbody><tr><td>FA=0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>FA=1</td><td>1</td><td>0</td><td>x</td><td>x</td></tr></tbody></table><p>我们需要由这个表格推导出 newFA 与 FA、SA、E的位运算关系：</p><ul><li>SA 为0时，缩小了取值范围，并覆盖了 newFA==1 的范围，即得出一个 &amp; 运算因子 ~SA</li><li>当 FA/E 为 0/1 或 1/0 时，进一步缩小了取值范围，且恰好与所有 newFA==1 的范围匹配，得出 &amp; 运算因子 FA^E</li></ul><p>所以newFA 与 FA、SA、E的位运算关系为 newFA = ~SA &amp; (FA^E)</p><p>newSA 的如下表格：</p><table><thead><tr><th>FA/E</th><th>0/0</th><th>0/1</th><th>1/0</th><th>1/1</th></tr></thead><tbody><tr><td>SA=0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>SA=1</td><td>1</td><td>0</td><td>x</td><td>x</td></tr></tbody></table><p>由这个表格推导 newSA 与 FA、SA、E的位运算关系：</p><ul><li>SA 与 E 相反时，缩小了取值范围，并覆盖了 newSA==1 的范围，即得出一个 &amp; 运算因子 SA^E</li><li>当 FA/E 为 0/0 或 1/1 时，进一步缩小了取值范围，且恰好与所有 newSA==1 的范围匹配，得出 &amp; 运算因子 ~(FA^E)</li></ul><p>所以newFA 与 FA、SA、E的位运算关系为 newSA = (SA^E) &amp; ~(FA^E)<br>之后再把 FA = newFA 和 SA = newSA 即可。<br><strong>PS</strong>:推导的原则基本上就是不断缩小取值范围，直至完全匹配，然后用 &amp; 连接运算因子。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>Swift code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4];</span><br><span class="line">var FA &#x3D; 0</span><br><span class="line">var SA &#x3D; 0</span><br><span class="line">var newFA &#x3D; 0</span><br><span class="line">var newSA &#x3D; 0</span><br><span class="line">for E in arr&#123;</span><br><span class="line">newFA &#x3D; (SA^E) &amp; ~(FA^E)</span><br><span class="line">newFA &#x3D; ~SA &amp; (FA^E)</span><br><span class="line">FA &#x3D; newFA</span><br><span class="line">SA &#x3D; newSA</span><br><span class="line">&#125;</span><br><span class="line">print(FA)</span><br><span class="line">&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><p><strong>PS</strong>:若是查找该数组中仅有的重复两次的元素，SA即是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;p&gt;给定一个大数组，它里面除了一个元素外，其他元素都重复了三次，要求在&lt;strong&gt;空间复杂度为O(1)&lt;/strong&gt;, &lt;str
      
    
    </summary>
    
    
      <category term="每周一算" scheme="https://sinianshou.github.io/categories/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%AE%97/"/>
    
    
      <category term="算法" scheme="https://sinianshou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="swift" scheme="https://sinianshou.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
